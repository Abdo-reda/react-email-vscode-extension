const languageTokensMap = new Map<string, string>([
  ["T_ABSTRACT", "abstract"],
  ["T_AMPERSAND_FOLLOWED_BY_VAR_OR_VARARG", "&"],
  ["T_AMPERSAND_NOT_FOLLOWED_BY_VAR_OR_VARARG", "&"],
  ["T_AND_EQUAL", "&="],
  ["T_ARRAY", "array()"],
  ["T_ARRAY_CAST", "(array)"],
  ["T_AS", "as"],
  ["T_ATTRIBUTE", "#["],
  ["T_BAD_CHARACTER", "Non-printable character"],
  ["T_BOOLEAN_AND", "&&"],
  ["T_BOOLEAN_OR", "||"],
  ["T_BOOL_CAST", "(bool) or (boolean)"],
  ["T_BREAK", "break"],
  ["T_CALLABLE", "callable"],
  ["T_CASE", "case"],
  ["T_CATCH", "catch"],
  ["T_CLASS", "class"],
  ["T_CLASS_C", "__CLASS__"],
  ["T_CLONE", "clone"],
  ["T_CLOSE_TAG", "?>/%>"],
  ["T_COALESCE", "??"],
  ["T_COALESCE_EQUAL", "??="],
  ["T_COMMENT", "//, #, /* */"],
  ["T_CONCAT_EQUAL", ".="],
  ["T_CONST", "const"],
  ["T_CONSTANT_ENCAPSED_STRING", "\"foo\" or 'bar'"],
  ["T_CONTINUE", "continue"],
  ["T_CURLY_OPEN", "{"],
  ["T_DEC", "--"],
  ["T_DECLARE", "declare"],
  ["T_DEFAULT", "default"],
  ["T_DIR", "__DIR__"],
  ["T_DIV_EQUAL", "/="],
  ["T_DNUMBER", "0.12, etc."],
  ["T_DO", "do"],
  ["T_DOC_COMMENT", "/** */"],
  ["T_DOLLAR_OPEN_CURLY_BRACES", "${"],
  ["T_DOUBLE_ARROW", "=>"],
  ["T_DOUBLE_CAST", "(real), (double) or (float)"],
  ["T_DOUBLE_COLON", "::"],
  ["T_ECHO", "echo"],
  ["T_ELLIPSIS", "..."],
  ["T_ELSE", "else"],
  ["T_ELSEIF", "elseif"],
  ["T_EMPTY", "empty"],
  ["T_ENCAPSED_AND_WHITESPACE", "\" $a\""],
  ["T_ENDDECLARE", "enddeclare"],
  ["T_ENDFOR", "endfor"],
  ["T_ENDFOREACH", "endforeach"],
  ["T_ENDIF", "endif"],
  ["T_ENDSWITCH", "endswitch"],
  ["T_ENDWHILE", "endwhile"],
  ["T_ENUM", "enum"],
  ["T_END_HEREDOC", "end heredoc"],
  ["T_EVAL", "eval()"],
  ["T_EXIT", "exi or /die"],
  ["T_EXTENDS", "extends"],
  ["T_FILE", "__FILE__"],
  ["T_FINAL", "final"],
  ["T_FINALLY", "finally"],
  ["T_FN", "fn"],
  ["T_FOR", "for"],
  ["T_FOREACH", "foreach"],
  ["T_FUNCTION", "function"],
  ["T_FUNC_C", "__FUNCTION__"],
  ["T_GLOBAL", "global"],
  ["T_GOTO", "goto"],
  ["T_HALT_COMPILER", "__halt_compiler()"],
  ["T_IF", "if"],
  ["T_IMPLEMENTS", "implements"],
  ["T_INC", "++"],
  ["T_INCLUDE", "include"],
  ["T_INCLUDE_ONCE", "include_once"],
  ["T_INLINE_HTML", "INLINE HTML"],
  ["T_INSTANCEOF", "instanceof"],
  ["T_INSTEADOF", "insteadof"],
  ["T_INTERFACE", "interface"],
  ["T_INT_CAST", "(int) or (integer)"],
  ["T_ISSET", "isset()"],
  ["T_IS_EQUAL", "=="],
  ["T_IS_GREATER_OR_EQUAL", ">="],
  ["T_IS_IDENTICAL", "==="],
  ["T_IS_NOT_EQUAL", "!= or <>"],
  ["T_IS_NOT_IDENTICAL", "!=="],
  ["T_IS_SMALLER_OR_EQUAL", "<="],
  ["T_LINE", "__LINE__"],
  ["T_LIST", "list()"],
  ["T_LNUMBER", "123, 012, 0x1ac, etc."],
  ["T_LOGICAL_AND", "and"],
  ["T_LOGICAL_OR", "or"],
  ["T_LOGICAL_XOR", "xor"],
  ["T_MATCH", "match"],
  ["T_METHOD_C", "__METHOD__"],
  ["T_MINUS_EQUAL", "-="],
  ["T_MOD_EQUAL", "%="],
  ["T_MUL_EQUAL", "*="],
  ["T_NAMESPACE", "namespace"],
  ["T_NAME_FULLY_QUALIFIED", "\\App\\Namespace"],
  ["T_NAME_QUALIFIED", "App\\Namespace"],
  ["T_NAME_RELATIVE", "namespace\\Namespace"],
  ["T_NEW", "new"],
  ["T_NS_C", "__NAMESPACE__"],
  ["T_NS_SEPARATOR", "\\"],
  ["T_NUM_STRING", "\"$a[0]\""],
  ["T_OBJECT_CAST", "(object)"],
  ["T_OBJECT_OPERATOR", "->"],
  ["T_NULLSAFE_OBJECT_OPERATOR", "?->"],
  ["T_OPEN_TAG", "<?php, <? or <%"],
  ["T_OPEN_TAG_WITH_ECHO", "<?= or <%="],
  ["T_OR_EQUAL", "|="],
  ["T_PAAMAYIM_NEKUDOTAYIM", "::"],
  ["T_PLUS_EQUAL", "+="],
  ["T_POW", "**"],
  ["T_POW_EQUAL", "**="],
  ["T_PRINT", "print"],
  ["T_PRIVATE", "private"],
  ["T_PRIVATE_SET", "private(set)"],
  ["T_PROTECTED", "protected"],
  ["T_PROTECTED_SET", "protected(set)"],
  ["T_PUBLIC", "public"],
  ["T_PUBLIC_SET", "public(set)"],
  ["T_READONLY", "readonly"],
  ["T_REQUIRE", "require"],
  ["T_REQUIRE_ONCE", "require_once"],
  ["T_RETURN", "return"],
  ["T_SL", "<<"],
  ["T_SL_EQUAL", "<<="],
  ["T_SPACESHIP", "<=>"],
  ["T_SR", ">>"],
  ["T_SR_EQUAL", ">>="],
  ["T_START_HEREDOC", "<<<"],
  ["T_STATIC", "static"],
  ["T_STRING", "parent, self, etc."],
  ["T_STRING_CAST", "(string)"],
  ["T_STRING_VARNAME", "\"${a"],
  ["T_SWITCH", "switch"],
  ["T_THROW", "throw"],
  ["T_TRAIT", "trait"],
  ["T_TRAIT_C", "__TRAIT__"],
  ["T_TRY", "try"],
  ["T_UNSET", "unset()"],
  ["T_UNSET_CAST", "(unset)"],
  ["T_USE", "use"],
  ["T_VAR", "var"],
  ["T_VARIABLE", "$foo"],
  ["T_WHILE", "while"],
  ["T_WHITESPACE", "\\t \\r\\n"],
  ["T_XOR_EQUAL", "^="],
  ["T_YIELD", "yield"],
  ["T_YIELD_FROM", "yield from"],
]);


// Build a single regex pattern and a lookup object for quick replacement
const tokenRegex = new RegExp(
  [...languageTokensMap.keys()]
    .map((token) => `\\b${token}\\b`) // Add word boundaries to each token
    .join("|"),
  "g" // Global flag for multiple replacements
);

const tokenLookup = Object.fromEntries(languageTokensMap);

/**
 * Replace all occurrences of token names in the string with their corresponding symbols.
 * @param input The string to process.
 * @returns The modified string.
 */
export default function replaceTokens(input: string): string {
  return input.replace(tokenRegex, (matched) => `'${tokenLookup[matched]}'`);
}